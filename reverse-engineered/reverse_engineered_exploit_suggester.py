#!/usr/bin/python

# Focus on Windows and Linux x86_64 and x86 ONLY
# This project WILL TAKE A WHILE

# tunnel is a dict array of 'host',port relational array
# The SSH tunnel functions as a RPC method where it can automatically run commands in the shell session.

# need to find a way to share tty to the tunnel. So we can create for example, a tunnel listening on port 10000 that forwards all stdin to the console netcat session on port 4444

# The exploit dictionary is a csv file with command,output,exploit. 
exploitDict = {}

# xx1 = text file of exploits, shell commands to validate it, and output string to match
xx1 = ""
def readExploitDict(xx1):
    # reads the exploit dictionary file and then appends it to a two dimensional array where the structure is
    #{exploit,[command,output]}
    #{exploit:{command:output}}
    exploitDict = {exploit:{command:output}}
    # How it works is if the returned output from the privChecker equals exploit[command], then it evaluates as True and notifies the user
    return exploitDict

exploitDict = readExploitDict(xx1)
def tunnelCreate(session):

    host=str(x)
    port=int(y)

    tunnel = {host,port}
    return tunnel
def tunnelAttach(tunnel):
    return

def tunnelInteract(tunnel,cmd):
    # Creates a forked process that runs a command through the tunnel, and then prints stdout back to parent process.
    o = pexpect.spawn()
    return output

def idenPlatform(session):
    return platform

def idenArch(session);
    return arch

# How Metasploit's local exploit suggester works is...
# 1. Determine session interactivity
# 2. Determine loading of the meterpeter stdapi framework
# 3. Determine platform, architecture, shell environment, versioning (different platform versions have limited ranges of commands like cmd.exe, netsh, powershell, sh, bash)
# 4. It then uses the msfconsole datastore to match up all relevant privescs and then checks for compatibility.
# 5. Step #4 is going to be a long process to reverse engineer. I need to reverse engineer EVERY privesc for x86 and x86_64 for linux and windows.

def privChecker(session):
    # Make a unique vulnerability log file by the output of date/time function.
    fname = "/tmp/vulnerability_log_{}".format(str(time))
    tunnel = tunnelAttach(session)
    # this is a backgrounded pexpect function, that forks on its own and runs the checks
    tunnelAttach(tunnel)
    platform = idenPlatform(session)
    arch = idenArch(session)

    if platform == "windows":
        outputDict = {}
        shellCommands = importShellCommands(textFileOfWindowsShellCommands)
        for c in shellCommands:
            # tunnelInteract uses at least 4 modules, pexpect, subprocess, threading, asyncio
            output = tunnelInteract(tunnel,c)
            print output
            stdout = outputDict[c]
        for commandRun in outputDict:
            result = outputDict[commandRun]
            if checkStdout(commandRun,result) == True:
                Exploit = exploitDict[commandRun]
                print "Exploit Verified: {Exploit}"
                Vulnerabilities.append(Exploit)
        for v in Vulnerabilities:
            print "Vulnerable: {v}"
            w = open(vulnlog,'w+')
            w.write(v)
            w.close()
        return
    if platform == "linux":
        shellCommands = importShellCommands(textFileofLinuxShellCommands)

        return

    return